{"title": "Representing Qubit States", "content": "If you think quantum mechanics sounds challenging, you are not alone. All of our intuitions are based on day-to-day experiences, and so are better at understanding the behavior of balls and bananas than atoms or electrons. Though quantum objects can seem random and chaotic at first, they just follow a different set of rules. Once we know what those rules are, we can use them to create new and powerful technology. Quantum computing will be the most revolutionary example of this. To get you started on your journey towards quantum computing, let's test what you already know.   Which of the following is the correct description of a bit? Actually, they are all correct: it's a very multi-purpose word! But if you chose \"the smallest unit of information\", it shows that you are already thinking along the right lines. The idea that information can be stored and processed as a series of 0s and 1s is quite a big conceptual hurdle, but it's something most people today know without even thinking about it. Taking this as a starting point, we can start to imagine bits that obey the rules of quantum mechanics. These quantum bits, or qubits, will then allow us to process information in new and different ways. We'll start diving deeper into the world of qubits. For this, we'll need some way of keeping track of what they are doing when we apply gates. The most powerful way to do this is to use the mathematical language of vectors and matrices. This chapter will be most effective for readers who are already familiar with vectors and matrices. Those who aren't familiar will likely be fine too, though it might be useful to consult our Introduction to Linear Algebra for Quantum Computing from time to time. Since we will be using Qiskit, our Python-based framework for quantum computing, it would also be useful to know the basics of Python. Those who need a primer can consult the Introduction to Python and Jupyter notebooks. If you think quantum mechanics sounds challenging, you are not alone. All of our intuitions are based on day-to-day experiences, and so are better at understanding the behavior of balls and bananas than atoms or electrons. Though quantum objects can seem random and chaotic at first, they just follow a different set of rules. Once we know what those rules are, we can use them to create new and powerful technology. Quantum computing will be the most revolutionary example of this. To get you started on your journey towards quantum computing, let's test what you already know.   Which of the following is the correct description of a bit? Actually, they are all correct: it's a very multi-purpose word! But if you chose \"the smallest unit of information\", it shows that you are already thinking along the right lines. The idea that information can be stored and processed as a series of 0s and 1s is quite a big conceptual hurdle, but it's something most people today know without even thinking about it. Taking this as a starting point, we can start to imagine bits that obey the rules of quantum mechanics. These quantum bits, or qubits, will then allow us to process information in new and different ways. We'll start diving deeper into the world of qubits. For this, we'll need some way of keeping track of what they are doing when we apply gates. The most powerful way to do this is to use the mathematical language of vectors and matrices. This chapter will be most effective for readers who are already familiar with vectors and matrices. Those who aren't familiar will likely be fine too, though it might be useful to consult our Introduction to Linear Algebra for Quantum Computing from time to time. Since we will be using Qiskit, our Python-based framework for quantum computing, it would also be useful to know the basics of Python. Those who need a primer can consult the Introduction to Python and Jupyter notebooks. Programming a quantum computer is now something that anyone can do in the comfort of their own home. But what to create? What is a quantum program anyway? In fact, what is a quantum computer? These questions can be answered by making comparisons to standard digital computers. Unfortunately, most people don\u2019t actually understand how digital computers work either. In this article, we\u2019ll look at the basics principles behind these devices. To help us transition over to quantum computing later on, we\u2019ll do it using the same tools as we'll use for quantum. Below is some Python code we'll need to run if we want to use the code in this page:   The first thing we need to know about is the idea of bits. These are designed to be the world\u2019s simplest alphabet. With only two characters, 0 and 1, we can represent any piece of information. One example is numbers. You are probably used to representing a number through a string of the ten digits 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. In this string of digits, each digit represents how many times the number contains a certain power of ten. For example, when we write 9213, we mean \\begin{align*} 9000 + 200 + 10 + 3 \\end{align*} or, expressed in a way that emphasizes the powers of ten \\begin{align*} (9\\times10^3) + (2\\times10^2) + (1\\times10^1) + (3\\times10^0) \\end{align*} Though we usually use this system based on the number 10, we can just as easily use one based on any other number. The binary number system, for example, is based on the number two. This means using the two characters 0 and 1 to express numbers as multiples of powers of two. For example, 9213 becomes 10001111111101, since \\begin{align*}\\begin{aligned} 9213 &= (1 \\times 2^{13}) + (0 \\times 2^{12}) + (0 \\times 2^{11}) + (0 \\times 2^{10}) \\\\ &+ (1 \\times 2^9) + (1 \\times 2^8) + (1 \\times 2^7) + (1 \\times 2^6) \\\\ &+ (1 \\times 2^5) + (1 \\times 2^4) + (1 \\times 2^3) + (1 \\times 2^2) \\\\ &+ (0 \\times 2^1) + (1 \\times 2^0) \\end{aligned}\\end{align*} In this we are expressing numbers as multiples of 2, 4, 8, 16, 32, etc. instead of 10, 100, 1000, etc. These strings of bits, known as binary strings, can be used to represent more than just numbers. For example, there is a way to represent any text using bits. For any letter, number, or punctuation mark you want to use, you can find a corresponding string of at most eight bits using this table. Though these are quite arbitrary, this is a widely agreed-upon standard. In fact, it's what was used to transmit this article to you through the internet. This is how all information is represented in computers. Whether numbers, letters, images, or sound, it all exists in the form of binary strings. Like our standard digital computers, quantum computers are based on this same basic idea. The main difference is that they use qubits, an extension of the bit to quantum mechanics. In the rest of this textbook, we will explore what qubits are, what they can do, and how they do it. In this section, however, we are not talking about quantum at all. So, we just use qubits as if they were bits. Complete these sentences:   Whether we are using qubits or bits, we need to manipulate them in order to turn the inputs we have into the outputs we need. For the simplest programs with very few bits, it is useful to represent this process in a diagram known as a circuit diagram. These have inputs on the left, outputs on the right, and operations represented by arcane symbols in between. These operations are called 'gates', mostly for historical reasons. Here's an example of what a circuit looks like for standard, bit-based computers. You aren't expected to understand what it does. It should simply give you an idea of what these circuits look like. For quantum computers, we use the same basic idea but have different conventions for how to represent inputs, outputs, and the symbols used for operations. Here is the quantum circuit that represents the same process as above. In the rest of this section, we will explain how to build circuits. At the end, you'll know how to create the circuit above, what it does, and why it is useful.   In a circuit, we typically need to do three jobs: First, encode the input, then do some actual computation, and finally extract an output. For your first quantum circuit, we'll focus on the last of these jobs. We start by creating a circuit with eight qubits and eight outputs. This circuit, which we have called qc_output, is created by Qiskit using QuantumCircuit. The QuantumCircuit takes the number of qubits in the quantum circuit as an argument.  The extraction of outputs in a quantum circuit is done using an operation called measure_all(). Each measurement tells a specific qubit to give an output to a specific output bit. The command qc_output.measure_all() adds a measurement to each qubit in the circuit qc_output, and also adds some classical bits to write the output to. Now that our circuit has something in it, let's take a look at it. Qubits are always initialized to give the output 0. Since we don't do anything to our qubits in the circuit above, this is exactly the result we'll get when we measure them. We can see this by running the circuit many times and plotting the results in a histogram. We will find that the result is always 0: a 0 from each qubit. The reason for running many times and showing the result as a histogram is because quantum computers may have some randomness in their results. In this case, since we aren\u2019t doing anything quantum, we get just the 0 result with certainty. Note that this result comes from a quantum simulator, which is a standard computer calculating what an ideal quantum computer would do. Simulations are only possible for small numbers of qubits (~30 qubits), but they are nevertheless a very useful tool when designing your first quantum circuits. To run on a real device you simply need to replace Aer.getbackend\u2019aersimulator\u2019 with the backend object of the device you want to use.        Now let's look at how to encode a different binary string as an input. For this, we need what is known as a NOT gate. This is the most basic operation that you can do in a computer. It simply flips the bit value: 0 becomes 1 and 1 becomes 0. For qubits, it is an operation called x that does the job of the NOT. Below we create a new circuit dedicated to the job of encoding and call it qc_encode. For now, we only specify the number of qubits. Extracting results can be done using the circuit we have from before: qc_output. Now we can run the combined circuit and look at the results. Now our computer outputs the string 10000000 instead. The bit we flipped, which comes from qubit 7, lives on the far left of the string. This is because Qiskit numbers the bits in a string from right to left. Some prefer to number their bits the other way around, but Qiskit's system certainly has its advantages when we are using the bits to represent numbers. Specifically, it means that qubit 7 is telling us about how many 2^7s we have in our number. So by flipping this bit, we\u2019ve now written the number 1282566432 in our simple 8-bit computer. Now try out writing another number for yourself. You could do your age, for example. Just use a search engine to find out what the number looks like in binary (if it includes a \u20180b\u2019, just ignore it), and then add some 0s to the left side if you are younger than 128. Now we know how to encode information in a computer. The next step is to process it: To take an input that we have encoded, and turn it into an output that we need.   To look at turning inputs into outputs, we need a problem to solve. Let\u2019s do some basic maths. In primary school, you will have learned how to take large mathematical problems and break them down into manageable pieces. For example, how would you go about solving the following? One way is to do it digit by digit, from right to left. So we start with 3+4 And then 1+5 Then we have 2+8=10. Since this is a two digit answer, we need to carry the one over to the next column. Finally we have 9+1+1=11, and get our answer This may just be simple addition, but it demonstrates the principles behind all algorithms. Whether the algorithm is designed to solve mathematical problems or process text or images, we always break big tasks down into small and simple steps. To run on a computer, algorithms need to be compiled down to the smallest and simplest steps possible. To see what these look like, let\u2019s do the above addition problem again but in binary. Note that the second number has a bunch of extra 0s on the left. This just serves to make the two strings the same length. Our first task is to do the 1+0 for the column on the right. In binary, as in any number system, the answer is 1. We get the same result for the 0+1 of the second column. Next, we have 1+1. As you\u2019ll surely be aware, 1+1=2. In binary, the number 2 is written 10, and so requires two bits. This means that we need to carry the 1, just as we would for the number 10 in decimal. The next column now requires us to calculate 1+1+1. This means adding three numbers together, so things are getting complicated for our computer. But we can still compile it down to simpler operations, and do it in a way that only ever requires us to add two bits together. For this, we can start with just the first two 1s. Now we need to add this 10 to the final 1 , which can be done using our usual method of going through the columns. The final answer is 11 (also known as 3). Now we can get back to the rest of the problem. With the answer of 11, we have another carry bit. So now we have another 1+1+1 to do. But we already know how to do that, so it\u2019s not a big deal. In fact, everything left so far is something we already know how to do. This is because, if you break everything down into adding just two bits, there are only four possible things you\u2019ll ever need to calculate. Here are the four basic sums (we\u2019ll write all the answers with two bits to be consistent). This is called a half adder. If our computer can implement this, and if it can chain many of them together, it can add anything.   Let's make our own half adder using Qiskit. This will include a part of the circuit that encodes the input, a part that executes the algorithm, and a part that extracts the result. The first part will need to be changed whenever we want to use a new input, but the rest will always remain the same. The two bits we want to add are encoded in the qubits 0 and 1. The above example encodes a 1 in both these qubits, and so it seeks to find the solution of 1+1. The result will be a string of two bits, which we will read out from the qubits 2 and 3 and store in classical bits 0 and 1, respectively. The basic operations of computing are known as logic gates. We\u2019ve already used the NOT gate, but this is not enough to make our half adder. We could only use it to manually write out the answers. Since we want the computer to do the actual computing for us, we\u2019ll need some more powerful gates. To see what we need, let\u2019s take another look at what our half adder needs to do. The rightmost bit in all four of these answers is completely determined by whether the two bits we are adding are the same or different. So for 0+0 and 1+1, where the two bits are equal, the rightmost bit of the answer comes out 01. For 0+1 and 1+0, where we are adding different bit values, the rightmost bit is 10. To get this part of our solution correct, we need something that can figure out whether two bits are different or not. Traditionally, in the study of digital computation, this is called an XOR gate. In quantum computers, the job of the XOR gate is done by the controlled-NOT gate. Since that's quite a long name, we usually just call it the CNOT. In Qiskit its name is cx, which is even shorter. In circuit diagrams, it is drawn as in the image below. This is applied to a pair of qubits. One acts as the control qubit (this is the one with the little dot). The other acts as the target qubit (with the big circle that has a + inside it). There are multiple ways to explain the effect of the CNOT. One is to say that it looks at its two input bits to see whether they are the same or different. Next, it overwrites the target qubit with the answer. The target becomes 0 if they are the same, and 1 if they are different. Another way of explaining the CNOT is to say that it does a NOT on the target if the control is 1, and does nothing otherwise. This explanation is just as valid as the previous one (in fact, it\u2019s the one that gives the gate its name). Try the CNOT out for yourself by trying each of the possible inputs. For example, here's a circuit that tests the CNOT with the input 1. If you execute this circuit, you\u2019ll find that the output is 11. We can think of this happening because of either of the following reasons. The CNOT calculates whether the input values are different and finds that they are, which means that it wants to output 1. It does this by writing over the state of qubit 1 (which, remember, is on the left of the bit string), turning 1 into 11. The CNOT sees that qubit 0 is in state 1, and so applies a NOT to qubit 1. This flips the 0 of qubit 1 into a 1, and so turns 1 into 11. Here is a table showing all the possible inputs and corresponding outputs of the CNOT gate: For our half adder, we don\u2019t want to overwrite one of our inputs. Instead, we want to write the result on a different pair of qubits. For this, we can use two CNOTs. We are now halfway to a fully working half adder. We just have the other bit of the output left to do: the one that will live on qubit 3. If you look again at the four possible sums, you\u2019ll notice that there is only one case for which this is 1 instead of 0: 1+1=10. It happens only when both the bits we are adding are 1. To calculate this part of the output, we could just get our computer to look at whether both of the inputs are 1. If they are\u200a\u2014\u200aand only if they are\u200a\u2014\u200awe need to do a NOT gate on qubit 3. That will flip it to the required value of 1 for this case only, giving us the output we need. For this, we need a new gate: like a CNOT but controlled on two qubits instead of just one. This will perform a NOT on the target qubit only when both controls are in state 1. This new gate is called the Toffoli. For those of you who are familiar with Boolean logic gates, it is basically an AND gate. In Qiskit, the Toffoli is represented with the ccx command. In this example, we are calculating 1+1, because the two input bits are both 1. Let's see what we get. The result is 10, which is the binary representation of the number 2. We have built a computer that can solve the famous mathematical problem of 1+1! Now you can try it out with the other three possible inputs, and show that our algorithm gives the right results for those too. The half adder contains everything you need for addition. With the NOT, CNOT, and Toffoli gates, we can create programs that add any set of numbers of any size. These three gates are enough to do everything else in computing too. In fact, we can even do without the CNOT. Additionally, the NOT gate is only really needed to create bits with value 1. The Toffoli gate is essentially the atom of mathematics. It is the simplest element, from which every other problem-solving technique can be compiled. As we'll see, in quantum computing we split the atom. Programming a quantum computer is now something that anyone can do in the comfort of their own home. But what to create? What is a quantum program anyway? In fact, what is a quantum computer? These questions can be answered by making comparisons to standard digital computers. Unfortunately, most people don\u2019t actually understand how digital computers work either. In this article, we\u2019ll look at the basics principles behind these devices. To help us transition over to quantum computing later on, we\u2019ll do it using the same tools as we'll use for quantum. Below is some Python code we'll need to run if we want to use the code in this page:   The first thing we need to know about is the idea of bits. These are designed to be the world\u2019s simplest alphabet. With only two characters, 0 and 1, we can represent any piece of information. One example is numbers. You are probably used to representing a number through a string of the ten digits 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. In this string of digits, each digit represents how many times the number contains a certain power of ten. For example, when we write 9213, we mean \\begin{align*} 9000 + 200 + 10 + 3 \\end{align*} or, expressed in a way that emphasizes the powers of ten \\begin{align*} (9\\times10^3) + (2\\times10^2) + (1\\times10^1) + (3\\times10^0) \\end{align*} Though we usually use this system based on the number 10, we can just as easily use one based on any other number. The binary number system, for example, is based on the number two. This means using the two characters 0 and 1 to express numbers as multiples of powers of two. For example, 9213 becomes 10001111111101, since \\begin{align*}\\begin{aligned} 9213 &= (1 \\times 2^{13}) + (0 \\times 2^{12}) + (0 \\times 2^{11}) + (0 \\times 2^{10}) \\\\ &+ (1 \\times 2^9) + (1 \\times 2^8) + (1 \\times 2^7) + (1 \\times 2^6) \\\\ &+ (1 \\times 2^5) + (1 \\times 2^4) + (1 \\times 2^3) + (1 \\times 2^2) \\\\ &+ (0 \\times 2^1) + (1 \\times 2^0) \\end{aligned}\\end{align*} In this we are expressing numbers as multiples of 2, 4, 8, 16, 32, etc. instead of 10, 100, 1000, etc. These strings of bits, known as binary strings, can be used to represent more than just numbers. For example, there is a way to represent any text using bits. For any letter, number, or punctuation mark you want to use, you can find a corresponding string of at most eight bits using this table. Though these are quite arbitrary, this is a widely agreed-upon standard. In fact, it's what was used to transmit this article to you through the internet. This is how all information is represented in computers. Whether numbers, letters, images, or sound, it all exists in the form of binary strings. Like our standard digital computers, quantum computers are based on this same basic idea. The main difference is that they use qubits, an extension of the bit to quantum mechanics. In the rest of this textbook, we will explore what qubits are, what they can do, and how they do it. In this section, however, we are not talking about quantum at all. So, we just use qubits as if they were bits. Complete these sentences:   Whether we are using qubits or bits, we need to manipulate them in order to turn the inputs we have into the outputs we need. For the simplest programs with very few bits, it is useful to represent this process in a diagram known as a circuit diagram. These have inputs on the left, outputs on the right, and operations represented by arcane symbols in between. These operations are called 'gates', mostly for historical reasons. Here's an example of what a circuit looks like for standard, bit-based computers. You aren't expected to understand what it does. It should simply give you an idea of what these circuits look like. For quantum computers, we use the same basic idea but have different conventions for how to represent inputs, outputs, and the symbols used for operations. Here is the quantum circuit that represents the same process as above. In the rest of this section, we will explain how to build circuits. At the end, you'll know how to create the circuit above, what it does, and why it is useful.   In a circuit, we typically need to do three jobs: First, encode the input, then do some actual computation, and finally extract an output. For your first quantum circuit, we'll focus on the last of these jobs. We start by creating a circuit with eight qubits and eight outputs. This circuit, which we have called qc_output, is created by Qiskit using QuantumCircuit. The QuantumCircuit takes the number of qubits in the quantum circuit as an argument.  The extraction of outputs in a quantum circuit is done using an operation called measure_all(). Each measurement tells a specific qubit to give an output to a specific output bit. The command qc_output.measure_all() adds a measurement to each qubit in the circuit qc_output, and also adds some classical bits to write the output to. Now that our circuit has something in it, let's take a look at it. Qubits are always initialized to give the output 0. Since we don't do anything to our qubits in the circuit above, this is exactly the result we'll get when we measure them. We can see this by running the circuit many times and plotting the results in a histogram. We will find that the result is always 0: a 0 from each qubit. The reason for running many times and showing the result as a histogram is because quantum computers may have some randomness in their results. In this case, since we aren\u2019t doing anything quantum, we get just the 0 result with certainty. Note that this result comes from a quantum simulator, which is a standard computer calculating what an ideal quantum computer would do. Simulations are only possible for small numbers of qubits (~30 qubits), but they are nevertheless a very useful tool when designing your first quantum circuits. To run on a real device you simply need to replace Aer.getbackend\u2019aersimulator\u2019 with the backend object of the device you want to use.        Now let's look at how to encode a different binary string as an input. For this, we need what is known as a NOT gate. This is the most basic operation that you can do in a computer. It simply flips the bit value: 0 becomes 1 and 1 becomes 0. For qubits, it is an operation called x that does the job of the NOT. Below we create a new circuit dedicated to the job of encoding and call it qc_encode. For now, we only specify the number of qubits. Extracting results can be done using the circuit we have from before: qc_output. Now we can run the combined circuit and look at the results. Now our computer outputs the string 10000000 instead. The bit we flipped, which comes from qubit 7, lives on the far left of the string. This is because Qiskit numbers the bits in a string from right to left. Some prefer to number their bits the other way around, but Qiskit's system certainly has its advantages when we are using the bits to represent numbers. Specifically, it means that qubit 7 is telling us about how many 2^7s we have in our number. So by flipping this bit, we\u2019ve now written the number 1282566432 in our simple 8-bit computer. Now try out writing another number for yourself. You could do your age, for example. Just use a search engine to find out what the number looks like in binary (if it includes a \u20180b\u2019, just ignore it), and then add some 0s to the left side if you are younger than 128. Now we know how to encode information in a computer. The next step is to process it: To take an input that we have encoded, and turn it into an output that we need.   To look at turning inputs into outputs, we need a problem to solve. Let\u2019s do some basic maths. In primary school, you will have learned how to take large mathematical problems and break them down into manageable pieces. For example, how would you go about solving the following? One way is to do it digit by digit, from right to left. So we start with 3+4 And then 1+5 Then we have 2+8=10. Since this is a two digit answer, we need to carry the one over to the next column. Finally we have 9+1+1=11, and get our answer This may just be simple addition, but it demonstrates the principles behind all algorithms. Whether the algorithm is designed to solve mathematical problems or process text or images, we always break big tasks down into small and simple steps. To run on a computer, algorithms need to be compiled down to the smallest and simplest steps possible. To see what these look like, let\u2019s do the above addition problem again but in binary. Note that the second number has a bunch of extra 0s on the left. This just serves to make the two strings the same length. Our first task is to do the 1+0 for the column on the right. In binary, as in any number system, the answer is 1. We get the same result for the 0+1 of the second column. Next, we have 1+1. As you\u2019ll surely be aware, 1+1=2. In binary, the number 2 is written 10, and so requires two bits. This means that we need to carry the 1, just as we would for the number 10 in decimal. The next column now requires us to calculate 1+1+1. This means adding three numbers together, so things are getting complicated for our computer. But we can still compile it down to simpler operations, and do it in a way that only ever requires us to add two bits together. For this, we can start with just the first two 1s. Now we need to add this 10 to the final 1 , which can be done using our usual method of going through the columns. The final answer is 11 (also known as 3). Now we can get back to the rest of the problem. With the answer of 11, we have another carry bit. So now we have another 1+1+1 to do. But we already know how to do that, so it\u2019s not a big deal. In fact, everything left so far is something we already know how to do. This is because, if you break everything down into adding just two bits, there are only four possible things you\u2019ll ever need to calculate. Here are the four basic sums (we\u2019ll write all the answers with two bits to be consistent). This is called a half adder. If our computer can implement this, and if it can chain many of them together, it can add anything.   Let's make our own half adder using Qiskit. This will include a part of the circuit that encodes the input, a part that executes the algorithm, and a part that extracts the result. The first part will need to be changed whenever we want to use a new input, but the rest will always remain the same. The two bits we want to add are encoded in the qubits 0 and 1. The above example encodes a 1 in both these qubits, and so it seeks to find the solution of 1+1. The result will be a string of two bits, which we will read out from the qubits 2 and 3 and store in classical bits 0 and 1, respectively. The basic operations of computing are known as logic gates. We\u2019ve already used the NOT gate, but this is not enough to make our half adder. We could only use it to manually write out the answers. Since we want the computer to do the actual computing for us, we\u2019ll need some more powerful gates. To see what we need, let\u2019s take another look at what our half adder needs to do. The rightmost bit in all four of these answers is completely determined by whether the two bits we are adding are the same or different. So for 0+0 and 1+1, where the two bits are equal, the rightmost bit of the answer comes out 01. For 0+1 and 1+0, where we are adding different bit values, the rightmost bit is 10. To get this part of our solution correct, we need something that can figure out whether two bits are different or not. Traditionally, in the study of digital computation, this is called an XOR gate. In quantum computers, the job of the XOR gate is done by the controlled-NOT gate. Since that's quite a long name, we usually just call it the CNOT. In Qiskit its name is cx, which is even shorter. In circuit diagrams, it is drawn as in the image below. This is applied to a pair of qubits. One acts as the control qubit (this is the one with the little dot). The other acts as the target qubit (with the big circle that has a + inside it). There are multiple ways to explain the effect of the CNOT. One is to say that it looks at its two input bits to see whether they are the same or different. Next, it overwrites the target qubit with the answer. The target becomes 0 if they are the same, and 1 if they are different. Another way of explaining the CNOT is to say that it does a NOT on the target if the control is 1, and does nothing otherwise. This explanation is just as valid as the previous one (in fact, it\u2019s the one that gives the gate its name). Try the CNOT out for yourself by trying each of the possible inputs. For example, here's a circuit that tests the CNOT with the input 1. If you execute this circuit, you\u2019ll find that the output is 11. We can think of this happening because of either of the following reasons. The CNOT calculates whether the input values are different and finds that they are, which means that it wants to output 1. It does this by writing over the state of qubit 1 (which, remember, is on the left of the bit string), turning 1 into 11. The CNOT sees that qubit 0 is in state 1, and so applies a NOT to qubit 1. This flips the 0 of qubit 1 into a 1, and so turns 1 into 11. Here is a table showing all the possible inputs and corresponding outputs of the CNOT gate: For our half adder, we don\u2019t want to overwrite one of our inputs. Instead, we want to write the result on a different pair of qubits. For this, we can use two CNOTs. We are now halfway to a fully working half adder. We just have the other bit of the output left to do: the one that will live on qubit 3. If you look again at the four possible sums, you\u2019ll notice that there is only one case for which this is 1 instead of 0: 1+1=10. It happens only when both the bits we are adding are 1. To calculate this part of the output, we could just get our computer to look at whether both of the inputs are 1. If they are\u200a\u2014\u200aand only if they are\u200a\u2014\u200awe need to do a NOT gate on qubit 3. That will flip it to the required value of 1 for this case only, giving us the output we need. For this, we need a new gate: like a CNOT but controlled on two qubits instead of just one. This will perform a NOT on the target qubit only when both controls are in state 1. This new gate is called the Toffoli. For those of you who are familiar with Boolean logic gates, it is basically an AND gate. In Qiskit, the Toffoli is represented with the ccx command. In this example, we are calculating 1+1, because the two input bits are both 1. Let's see what we get. The result is 10, which is the binary representation of the number 2. We have built a computer that can solve the famous mathematical problem of 1+1! Now you can try it out with the other three possible inputs, and show that our algorithm gives the right results for those too. The half adder contains everything you need for addition. With the NOT, CNOT, and Toffoli gates, we can create programs that add any set of numbers of any size. These three gates are enough to do everything else in computing too. In fact, we can even do without the CNOT. Additionally, the NOT gate is only really needed to create bits with value 1. The Toffoli gate is essentially the atom of mathematics. It is the simplest element, from which every other problem-solving technique can be compiled. As we'll see, in quantum computing we split the atom. You now know something about bits, and about how our familiar digital computers work. All the complex variables, objects and data structures used in modern software are basically all just big piles of bits. Those of us who work on quantum computing call these classical variables. The computers that use them, like the one you are using to read this article, we call classical computers. In quantum computers, our basic variable is the qubit: a quantum variant of the bit. These have exactly the same restrictions as normal bits do: they can store only a single binary piece of information, and can only ever give us an output of 0 or 1-1 or 101-1. However, they can also be manipulated in ways that can only be described by quantum mechanics. This gives us new gates to play with, allowing us to find new ways to design algorithms. To fully understand these new gates, we first need to understand how to write down qubit states. For this we will use the mathematics of vectors, matrices, and complex numbers. Though we will introduce these concepts as we go, it would be best if you are comfortable with them already. If you need a more in-depth explanation or a refresher, you can find the guide here.     In quantum physics we use statevectors to describe the state of our system. Say we wanted to describe the position of a car along a track, this is a classical system so we could use a number x: \\begin{align*} x=4 \\end{align*} Alternatively, we could instead use a collection of numbers in a vector called a statevector. Each element in the statevector contains the probability of finding the car in a certain place: \\begin{align*} \\cssId{x_ket}{|x\\rangle} = \\cssId{vector}{\\begin{bmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}} \\begin{matrix} \\\\ \\\\ \\\\ \\leftarrow \\\\ \\\\ \\\\ \\\\ \\end{matrix} \\begin{matrix} \\\\ \\\\ \\text{Probability of} \\\\ \\text{car being at} \\\\ \\text{position 4} \\\\ \\\\ \\\\ \\end{matrix} \\end{align*} This isn\u2019t limited to position, we could also keep a statevector of all the possible speeds the car could have, and all the possible colours the car could be. With classical systems (like the car example above), this is a silly thing to do as it requires keeping huge vectors when we only really need one number. But as we will see in this chapter, statevectors happen to be a very good way of keeping track of quantum systems, including quantum computers.   Classical bits are always either 0 or 1 at every point during a computation. There is no more detail we can add to the state of a bit than this. So to write down the state of a of classical bit (c), we can just use these two binary values. For example: \\begin{align*} c = 0 \\end{align*} This restriction is lifted for quantum bits. Whether we get a 0 or a 1 from a qubit only needs to be well-defined when a measurement is made to extract an output. At that point, it must commit to one of these two options. At all other times, its state will be something more complex than can be captured by a simple binary value. To see how to describe these, we can first focus on the two simplest cases. As we saw in the last section, it is possible to prepare a qubit in a state for which it definitely gives the outcome 0 when measured. We need a name for this state. Let's be unimaginative and call it 0 . Similarly, there exists a qubit state that is certain to output a 1. We'll call this 1. These two states are completely mutually exclusiveinclusive. Either the qubit definitely outputs a 0, or it definitely outputs a 1. There is no overlap. One way to represent this with mathematics is to use two orthogonal vectors. \\begin{align*}\\cssId{ket0}{|0\\rangle} = \\begin{bmatrix} \\cssId{p0}{1} \\\\ \\cssId{p1}{0} \\end{bmatrix}, \\quad \\cssId{ket1}{|1\\rangle} =\\begin{bmatrix} \\cssId{p0}{0} \\\\ \\cssId{p1}{1} \\end{bmatrix}\\end{align*} This is a lot of notation to take in all at once. First, let's unpack the weird | and \\rangle. Their job is essentially just to remind us that we are talking about the vectors that represent qubit states labelled 0 and 1. This helps us distinguish them from things like the bit values 0 and 1 or the numbers 0 and 1. It is part of the bra-ket notation, introduced by Dirac. If you are not familiar with vectors, you can essentially just think of them as lists of numbers which we manipulate using certain rules. If you are familiar with vectors from your high school physics classes, you'll know that these rules make vectors well-suited for describing quantities with a magnitude and a direction. For example, the velocity of an object is described perfectly with a vector. However, the way we use vectors for quantum states is slightly different to this, so don't hold on too hard to your previous intuition. It's time to do something new! With vectors we can describe more complex states than just |0\\rangle and |1\\rangle. For example, consider the vector \\begin{align*}\\cssId{q0}{|q_0\\rangle} = \\begin{bmatrix} \\cssId{p0}{\\tfrac{1}{\\sqrt{2}}} \\\\ \\cssId{p1}{\\tfrac{i}{\\sqrt{2}}} \\end{bmatrix}\\end{align*} To understand what this state means, we'll need to use the mathematical rules for manipulating vectors. Specifically, we'll need to understand how to add vectors together and how to multiply them by scalars.   \\begin{align*} |a\\rangle = \\begin{bmatrix}a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{bmatrix}, \\quad |b\\rangle = \\begin{bmatrix}b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_n \\end{bmatrix} \\end{align*} \\begin{align*} |a\\rangle + |b\\rangle = \\begin{bmatrix}a_0 + b_0 \\\\ a_1 + b_1 \\\\ \\vdots \\\\ a_n + b_n \\end{bmatrix} \\end{align*} And to multiply a vector by a scalar, we multiply each element by the scalar: \\begin{align*} x|a\\rangle = \\begin{bmatrix}x \\times a_0 \\\\ x \\times a_1 \\\\ \\vdots \\\\ x \\times a_n \\end{bmatrix} \\end{align*} These two rules are used to rewrite the vector |q_0\\rangle (as shown above): \\begin{align*}\\begin{aligned} |q_0\\rangle &= \\tfrac{1}{\\sqrt{2}}|0\\rangle + \\tfrac{i}{\\sqrt{2}}|1\\rangle \\\\ &= \\tfrac{1}{\\sqrt{2}}\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} + \\tfrac{i}{\\sqrt{2}}\\begin{bmatrix}0 \\\\ 1\\end{bmatrix} \\\\ &= \\begin{bmatrix}\\tfrac{1}{\\sqrt{2}} \\\\ 0\\end{bmatrix} + \\begin{bmatrix}0 \\\\ \\tfrac{i}{\\sqrt{2}}\\end{bmatrix} \\\\ &= \\begin{bmatrix}\\tfrac{1}{\\sqrt{2}} \\\\ \\tfrac{i}{\\sqrt{2}} \\end{bmatrix} \\\\ \\end{aligned}\\end{align*}   And normalised means their magnitudes (length of the arrow) is equal to 1. The two vectors |0\\rangle and |1\\rangle are linearly independent, which means we cannot describe |0\\rangle in terms of |1\\rangle, and vice versa. However, using both the vectors |0\\rangle and |1\\rangle, and our rules of addition and multiplication by scalars, we can describe all possible vectors in 2D space: Because the vectors |0\\rangle and |1\\rangle are linearly independent, and can be used to describe any vector in 2D space using vector addition and scalar multiplication, we say the vectors |0\\rangle and |1\\rangle form a basis. In this case, since they are both orthogonal and normalised, we call it an orthonormal basis. Since the states |0\\rangle and |1\\rangle form an orthonormal basis, we can represent any 2D vector with a combination of these two states. This allows us to write the state of our qubit in the alternative form: \\begin{align*} \\cssId{q0}{|q_0\\rangle} = \\cssId{term1}{\\tfrac{1}{\\sqrt{2}}|0\\rangle} + \\cssId{term2}{\\tfrac{i}{\\sqrt{2}}|1\\rangle} \\end{align*} This vector, |q_0\\rangle is called the qubit's statevector, it tells us everything we could possibly know about this qubit. For now, we are only able to draw a few simple conclusions about this particular example of a statevector: it is not entirely |0\\rangle and not entirely |1\\rangle. Instead, it is described by a linear combination of the two. In quantum mechanics, we typically describe linear combinations such as this using the word 'superposition'. Though our example state |q_0\\rangle can be expressed as a superposition of |0\\rangle and |1\\rangle, it is no less a definite and well-defined qubit state than they are. To see this, we can begin to explore how a qubit can be manipulated.   First, we need to import all the tools we will need: In Qiskit, we use the QuantumCircuit object to store our circuits, this is essentially a list of the quantum operations on our circuit and the qubits they are applied to. In our quantum circuits, our qubits always start out in the state |0\\rangle. We can use the initialize() method to transform this into any state. We give initialize() the vector we want in the form of a list, and tell it which qubit(s) we want to initialize in this state: We can then use one of Qiskit\u2019s simulators to view the resulting state of our qubit. To get the results from our circuit, we use run to execute our circuit, giving the circuit and the backend as arguments. We then use .result() to get the result of this: from result, we can then get the final statevector using .get_statevector(): Note: Python uses j to represent i in complex numbers. We see a vector with two complex elements: 0.+0.j = 0, and 1.+0.j = 1. Let\u2019s now measure our qubit as we would in a real quantum computer and see the result: This time, instead of the statevector we will get the counts for the 0 and 1 results using .get_counts(): We can see that we (unsurprisingly) have a % chance of measuring |1\\rangle.  This time, let\u2019s instead put our qubit into a superposition and see what happens. We will use the state |q_0\\rangle from earlier in this section: \\begin{align*} |q_0\\rangle = \\tfrac{1}{\\sqrt{2}}|0\\rangle + \\tfrac{\\cssId{i}{i}}{\\sqrt{2}}|1\\rangle \\end{align*} We need to add these amplitudes to a python list. To add a complex amplitude, Python uses j for the imaginary unit (we normally call it \"i\" mathematically): And we then repeat the steps for initialising the qubit as before: We can see we have equallessgreater probability of measuring |0\\rangle compared to |1\\rangle. To explain this, we need to talk about measurement.       There is a simple rule for measurement. To find the probability of measuring a state |\\psi \\rangle in the state |x\\rangle we do: \\begin{align*}p(|x\\rangle) = | \\langle x| \\psi \\rangle|^2\\end{align*} The symbols \\langle and | tell us \\langle x | is a row vector. In quantum mechanics we call the column vectors kets and the row vectors bras. Together they make up bra-ket notation. Any ket |a\\rangle has a corresponding bra \\langle a|, and we convert between them using the conjugate transpose.   \\begin{align*} \\quad|a\\rangle = \\begin{bmatrix}a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{bmatrix} \\end{align*} To get the conjugate transpose, the matrix is transposed and the elements are complex conjugated (represented by the \"\u2217\" operation) where complex conjugate of a complex number is a number with an equal real part and an imaginary part equal in magnitude but opposite in sign. This gives the corresponding bra (row vector) as follows: \\begin{align*} \\langle a| = \\begin{bmatrix}a_0^*, & a_1^*, & \\dots & a_n^* \\end{bmatrix} \\end{align*}   \\begin{align*}\\langle a| = \\begin{bmatrix}a_0^*, & a_1^*, & \\dots & a_n^* \\end{bmatrix} \\end{align*} \\begin{align*}|b\\rangle = \\begin{bmatrix}b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_n \\end{bmatrix} \\end{align*} \\begin{align*}\\langle a|b\\rangle = a_0^* b_0 + a_1^* b_1 \\dots a_n^* b_n \\end{align*} We can see that the inner product of two vectors always gives us a scalar. A useful thing to remember is that the inner product of two orthogonal vectors is 0, for example if we have the orthogonal vectors |0\\rangle and |1\\rangle: \\begin{align*}\\langle1|0\\rangle = \\begin{bmatrix} 0 , & 1\\end{bmatrix}\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} = 0\\end{align*} Additionally, remember that the vectors |0\\rangle and |1\\rangle are also normalised (magnitudes are equal to 1): \\begin{align*}\\begin{aligned} \\langle0|0\\rangle &= \\begin{bmatrix} 1 , & 0\\end{bmatrix}\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} = 1 \\\\ \\langle1|1\\rangle &= \\begin{bmatrix} 0 , & 1\\end{bmatrix}\\begin{bmatrix}0 \\\\ 1\\end{bmatrix} = 1 \\end{aligned}\\end{align*} In the equation above, |x\\rangle can be any qubit state. To find the probability of measuring |x\\rangle, we take the inner product of |x\\rangle and the state we are measuring (in this case |\\psi\\rangle), then square the magnitude. This may seem a little convoluted, but it will soon become second nature. If we look at the state |q_0\\rangle from before, we can see the probability of measuring |0\\rangle is indeed 0.5: \\begin{align*}\\begin{aligned} |q_0\\rangle & = \\tfrac{1}{\\sqrt{2}}|0\\rangle + \\tfrac{i}{\\sqrt{2}}|1\\rangle \\\\ \\langle 0| q_0 \\rangle & = \\tfrac{1}{\\sqrt{2}}\\langle 0|0\\rangle + \\tfrac{i}{\\sqrt{2}}\\langle 0|1\\rangle \\\\ & = \\tfrac{1}{\\sqrt{2}}\\cdot 1 + \\tfrac{i}{\\sqrt{2}} \\cdot 0\\\\ & = \\tfrac{1}{\\sqrt{2}}\\\\ |\\langle 0| q_0 \\rangle|^2 & = \\tfrac{1}{2} \\end{aligned}\\end{align*} You should verify the probability of measuring |1\\rangle as an exercise. This rule governs how we get information out of quantum states. It is therefore very important for everything we do in quantum computation. It also immediately implies several important facts.       The rule shows us that amplitudes are related to probabilities. If we want the probabilities to add up to 1 (which they should!), we need to ensure that the statevector is properly normalized. Specifically, we need the magnitude of the state vector to be 1. \\begin{align*} \\langle\\psi|\\psi\\rangle = 1 \\end{align*} Thus if: \\begin{align*} |\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle \\end{align*} Then: \\begin{align*} |\\alpha|^2 + |\\beta|^2 = 1 \\end{align*} This explains the factors of \\sqrt{2} you have seen throughout this chapter. In fact, if we try to give initialize() a vector that isn\u2019t normalised, it will give us an error: You can check your answer in the widget below (accepts answers \u00b11% accuracy, you can use numpy terms such as 'pi' and 'sqrt()' in the vector):   The measurement rule gives us the probability p(|x\\rangle) that a state |\\psi\\rangle is measured as |x\\rangle. Nowhere does it tell us that |x\\rangle can only be either |0\\rangle or |1\\rangle. The measurements we have considered so far are in fact only one of an infinite number of possible ways to measure a qubit. For any orthogonal pair of states, we can define a measurement that would cause a qubit to choose between the two. This possibility will be explored more in the next section. For now, just bear in mind that |x\\rangle is not limited to being simply |0\\rangle or |1\\rangle.   We know that measuring the state |1\\rangle will give us the output 1 with certainty. But we are also able to write down states such as  \\begin{align*}\\begin{bmatrix}0 \\\\ i\\end{bmatrix} = i|1\\rangle.\\end{align*} To see how this behaves, we apply the measurement rule. \\begin{align*} |\\langle x| (i|1\\rangle) |^2 = | i \\langle x|1\\rangle|^2 = |\\langle x|1\\rangle|^2 \\end{align*} Here we find that the factor of i disappears once we take the magnitude of the complex number. This effect is completely independent of the measured state |x\\rangle. It does not matter what measurement we are considering, the probabilities for the state i|1\\rangle are identical to those for |1\\rangle. Since measurements are the only way we can extract any information from a qubit, this implies that these two states are equivalent in all ways that are physically relevant. More generally, we refer to any overall factor \\gamma on a state for which |\\gamma|=1 as a 'global phase'. States that differ only by a global phase are physically indistinguishable. \\begin{align*} |\\langle x| ( \\gamma |a\\rangle) |^2 = | \\gamma \\langle x|a\\rangle|^2 = |\\langle x|a\\rangle|^2 \\end{align*} Note that this is distinct from the phase difference between terms in a superposition, which is known as the 'relative phase'. This becomes relevant once we consider different types of measurement and multiple qubits.   We know that the amplitudes contain information about the probability of us finding the qubit in a specific state, but once we have measured the qubit, we know with certainty what the state of the qubit is. For example, if we measure a qubit in the state: \\begin{align*} |q\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\end{align*} And find it in the state |0\\rangle, if we measure again, there is a 100% chance of finding the qubit in the state |0\\rangle. This means the act of measuring changes the state of our qubits. \\begin{align*} |q\\rangle = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix} \\xrightarrow{\\text{Measure }|0\\rangle} |q\\rangle = |0\\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\end{align*} We sometimes refer to this as collapsing the state of the qubit. It is a potent effect, and so one that must be used wisely. For example, were we to constantly measure each of our qubits to keep track of their value at each point in a computation, they would always simply be in a well-defined state of either |0\\rangle or |1\\rangle. As such, they would be no different from classical bits and our computation could be easily replaced by a classical computation. To achieve truly quantum computation we must allow the qubits to explore more complex states. Measurements are therefore only used when we need to extract an output. This means that we often place all the measurements at the end of our quantum circuit.  We can demonstrate this using Qiskit\u2019s statevector simulator. Let's initialize a qubit in superposition: This should initialize our qubit in the state: \\begin{align*} |q\\rangle = \\tfrac{i}{\\sqrt{2}}|0\\rangle + \\tfrac{1}{\\sqrt{2}}|1\\rangle \\end{align*} We can verify this using the simulator: We can see here the qubit is initialized in the state [0.+0.70710678j 0.70710678+0.j], which is the state we expected. Let\u2019s now create a circuit where we measure this qubit: When we simulate this entire circuit, we can see that one of the amplitudes is always 0: You can re-run this cell a few times to reinitialize the qubit and measure it again. You will notice that either outcome is equally probable, but that the state of the qubit is never a superposition of |0\\rangle and |1\\rangle. Somewhat interestingly, the global phase on the state |0\\rangle survives, but since this is global phase, we can never measure it on a real quantum computer.   We can see that writing down a qubit\u2019s state requires keeping track of two complex numbers, but when using a real quantum computer we will only ever receive a yes-or-no (0 or 1) answer for each qubit. The output of a 10-qubit quantum computer will look like this: 0110111110 Just 10 bits, no superposition or complex amplitudes. When using a real quantum computer, we cannot see the states of our qubits mid-computation, as this would destroy them! This behaviour is not ideal for learning, so Qiskit provides different quantum simulators: By default, the aer_simulator mimics the execution of a real quantum computer, but will also allow you to peek at quantum states before measurement if we include certain instructions in our circuit. For example, here we have included the instruction .save_statevector(), which means we can use .get_statevector() on the result of the simulation.        We saw earlier in this chapter that the general state of a qubit (|q\\rangle) is: \\begin{align*}|q\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\end{align*} \\begin{align*}\\alpha, \\beta \\in \\mathbb{C}\\end{align*} (The second line tells us \\alpha and \\beta are complex numbers). The first two implications in section 2 tell us that we cannot differentiate between some of these states. This means we can be more specific in our description of the qubit.  Firstly, since we cannot measure global phase, we can only measure the difference in phase between the states |0\\rangle and |1\\rangle. Instead of having \\alpha and \\beta be complex, we can confine them to the real numbers and add a term to tell us the relative phase between them: \\begin{align*}|q\\rangle = \\alpha|0\\rangle + e^{i\\phi}\\beta|1\\rangle\\end{align*} \\begin{align*}\\alpha, \\beta, \\phi \\in \\mathbb{R}\\end{align*} Finally, since the qubit state must be normalised, i.e. \\begin{align*}\\sqrt{\\alpha^2 + \\beta^2} = 1\\end{align*} we can use the trigonometric identity: \\begin{align*}\\sqrt{\\sin^2{x} + \\cos^2{x}} = 1\\end{align*} to describe the real \\alpha and \\beta in terms of one variable, \\theta: \\begin{align*}\\alpha = \\cos{\\tfrac{\\theta}{2}}, \\quad \\beta=\\sin{\\tfrac{\\theta}{2}}\\end{align*} From this we can describe the state of any qubit using the two variables \\phi and \\theta: \\begin{align*}|q\\rangle = \\cos{\\tfrac{\\theta}{2}}|0\\rangle + e^{i\\phi}\\sin{\\tfrac{\\theta}{2}}|1\\rangle\\end{align*} \\begin{align*}\\theta, \\phi \\in \\mathbb{R}\\end{align*}   We want to plot our general qubit state: \\begin{align*}|q\\rangle = \\cos{\\tfrac{\\theta}{2}}|0\\rangle + e^{i\\phi}\\sin{\\tfrac{\\theta}{2}}|1\\rangle\\end{align*} If we interpret \\theta and \\phi as spherical co-ordinates (r = 1, since the magnitude of the qubit state is 1), we can plot any single qubit state on the surface of a sphere, known as the Bloch sphere. Below we have plotted a qubit in the state |{+}\\rangle. In this case, \\theta = \\pi/2 and \\phi = 0. (Qiskit has a function to plot a bloch sphere, plot_bloch_vector(), but at the time of writing it only takes cartesian coordinates. We have included a function that does the conversion automatically). You can also try this interactive Bloch sphere demo.     Use plot_bloch_vector() or plot_bloch_sphere_spherical() to plot a qubit in the states: We have also included below a widget that converts from spherical co-ordinates to cartesian, for use with plot_bloch_vector(): You now know something about bits, and about how our familiar digital computers work. All the complex variables, objects and data structures used in modern software are basically all just big piles of bits. Those of us who work on quantum computing call these classical variables. The computers that use them, like the one you are using to read this article, we call classical computers. In quantum computers, our basic variable is the qubit: a quantum variant of the bit. These have exactly the same restrictions as normal bits do: they can store only a single binary piece of information, and can only ever give us an output of 0 or 1-1 or 101-1. However, they can also be manipulated in ways that can only be described by quantum mechanics. This gives us new gates to play with, allowing us to find new ways to design algorithms. To fully understand these new gates, we first need to understand how to write down qubit states. For this we will use the mathematics of vectors, matrices, and complex numbers. Though we will introduce these concepts as we go, it would be best if you are comfortable with them already. If you need a more in-depth explanation or a refresher, you can find the guide here.     In quantum physics we use statevectors to describe the state of our system. Say we wanted to describe the position of a car along a track, this is a classical system so we could use a number x: \\begin{align*} x=4 \\end{align*} Alternatively, we could instead use a collection of numbers in a vector called a statevector. Each element in the statevector contains the probability of finding the car in a certain place: \\begin{align*} \\cssId{x_ket}{|x\\rangle} = \\cssId{vector}{\\begin{bmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}} \\begin{matrix} \\\\ \\\\ \\\\ \\leftarrow \\\\ \\\\ \\\\ \\\\ \\end{matrix} \\begin{matrix} \\\\ \\\\ \\text{Probability of} \\\\ \\text{car being at} \\\\ \\text{position 4} \\\\ \\\\ \\\\ \\end{matrix} \\end{align*} This isn\u2019t limited to position, we could also keep a statevector of all the possible speeds the car could have, and all the possible colours the car could be. With classical systems (like the car example above), this is a silly thing to do as it requires keeping huge vectors when we only really need one number. But as we will see in this chapter, statevectors happen to be a very good way of keeping track of quantum systems, including quantum computers.   Classical bits are always either 0 or 1 at every point during a computation. There is no more detail we can add to the state of a bit than this. So to write down the state of a of classical bit (c), we can just use these two binary values. For example: \\begin{align*} c = 0 \\end{align*} This restriction is lifted for quantum bits. Whether we get a 0 or a 1 from a qubit only needs to be well-defined when a measurement is made to extract an output. At that point, it must commit to one of these two options. At all other times, its state will be something more complex than can be captured by a simple binary value. To see how to describe these, we can first focus on the two simplest cases. As we saw in the last section, it is possible to prepare a qubit in a state for which it definitely gives the outcome 0 when measured. We need a name for this state. Let's be unimaginative and call it 0 . Similarly, there exists a qubit state that is certain to output a 1. We'll call this 1. These two states are completely mutually exclusiveinclusive. Either the qubit definitely outputs a 0, or it definitely outputs a 1. There is no overlap. One way to represent this with mathematics is to use two orthogonal vectors. \\begin{align*}\\cssId{ket0}{|0\\rangle} = \\begin{bmatrix} \\cssId{p0}{1} \\\\ \\cssId{p1}{0} \\end{bmatrix}, \\quad \\cssId{ket1}{|1\\rangle} =\\begin{bmatrix} \\cssId{p0}{0} \\\\ \\cssId{p1}{1} \\end{bmatrix}\\end{align*} This is a lot of notation to take in all at once. First, let's unpack the weird | and \\rangle. Their job is essentially just to remind us that we are talking about the vectors that represent qubit states labelled 0 and 1. This helps us distinguish them from things like the bit values 0 and 1 or the numbers 0 and 1. It is part of the bra-ket notation, introduced by Dirac. If you are not familiar with vectors, you can essentially just think of them as lists of numbers which we manipulate using certain rules. If you are familiar with vectors from your high school physics classes, you'll know that these rules make vectors well-suited for describing quantities with a magnitude and a direction. For example, the velocity of an object is described perfectly with a vector. However, the way we use vectors for quantum states is slightly different to this, so don't hold on too hard to your previous intuition. It's time to do something new! With vectors we can describe more complex states than just |0\\rangle and |1\\rangle. For example, consider the vector \\begin{align*}\\cssId{q0}{|q_0\\rangle} = \\begin{bmatrix} \\cssId{p0}{\\tfrac{1}{\\sqrt{2}}} \\\\ \\cssId{p1}{\\tfrac{i}{\\sqrt{2}}} \\end{bmatrix}\\end{align*} To understand what this state means, we'll need to use the mathematical rules for manipulating vectors. Specifically, we'll need to understand how to add vectors together and how to multiply them by scalars.   \\begin{align*} |a\\rangle = \\begin{bmatrix}a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{bmatrix}, \\quad |b\\rangle = \\begin{bmatrix}b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_n \\end{bmatrix} \\end{align*} \\begin{align*} |a\\rangle + |b\\rangle = \\begin{bmatrix}a_0 + b_0 \\\\ a_1 + b_1 \\\\ \\vdots \\\\ a_n + b_n \\end{bmatrix} \\end{align*} And to multiply a vector by a scalar, we multiply each element by the scalar: \\begin{align*} x|a\\rangle = \\begin{bmatrix}x \\times a_0 \\\\ x \\times a_1 \\\\ \\vdots \\\\ x \\times a_n \\end{bmatrix} \\end{align*} These two rules are used to rewrite the vector |q_0\\rangle (as shown above): \\begin{align*}\\begin{aligned} |q_0\\rangle &= \\tfrac{1}{\\sqrt{2}}|0\\rangle + \\tfrac{i}{\\sqrt{2}}|1\\rangle \\\\ &= \\tfrac{1}{\\sqrt{2}}\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} + \\tfrac{i}{\\sqrt{2}}\\begin{bmatrix}0 \\\\ 1\\end{bmatrix} \\\\ &= \\begin{bmatrix}\\tfrac{1}{\\sqrt{2}} \\\\ 0\\end{bmatrix} + \\begin{bmatrix}0 \\\\ \\tfrac{i}{\\sqrt{2}}\\end{bmatrix} \\\\ &= \\begin{bmatrix}\\tfrac{1}{\\sqrt{2}} \\\\ \\tfrac{i}{\\sqrt{2}} \\end{bmatrix} \\\\ \\end{aligned}\\end{align*}   And normalised means their magnitudes (length of the arrow) is equal to 1. The two vectors |0\\rangle and |1\\rangle are linearly independent, which means we cannot describe |0\\rangle in terms of |1\\rangle, and vice versa. However, using both the vectors |0\\rangle and |1\\rangle, and our rules of addition and multiplication by scalars, we can describe all possible vectors in 2D space: Because the vectors |0\\rangle and |1\\rangle are linearly independent, and can be used to describe any vector in 2D space using vector addition and scalar multiplication, we say the vectors |0\\rangle and |1\\rangle form a basis. In this case, since they are both orthogonal and normalised, we call it an orthonormal basis. Since the states |0\\rangle and |1\\rangle form an orthonormal basis, we can represent any 2D vector with a combination of these two states. This allows us to write the state of our qubit in the alternative form: \\begin{align*} \\cssId{q0}{|q_0\\rangle} = \\cssId{term1}{\\tfrac{1}{\\sqrt{2}}|0\\rangle} + \\cssId{term2}{\\tfrac{i}{\\sqrt{2}}|1\\rangle} \\end{align*} This vector, |q_0\\rangle is called the qubit's statevector, it tells us everything we could possibly know about this qubit. For now, we are only able to draw a few simple conclusions about this particular example of a statevector: it is not entirely |0\\rangle and not entirely |1\\rangle. Instead, it is described by a linear combination of the two. In quantum mechanics, we typically describe linear combinations such as this using the word 'superposition'. Though our example state |q_0\\rangle can be expressed as a superposition of |0\\rangle and |1\\rangle, it is no less a definite and well-defined qubit state than they are. To see this, we can begin to explore how a qubit can be manipulated.   First, we need to import all the tools we will need: In Qiskit, we use the QuantumCircuit object to store our circuits, this is essentially a list of the quantum operations on our circuit and the qubits they are applied to. In our quantum circuits, our qubits always start out in the state |0\\rangle. We can use the initialize() method to transform this into any state. We give initialize() the vector we want in the form of a list, and tell it which qubit(s) we want to initialize in this state: We can then use one of Qiskit\u2019s simulators to view the resulting state of our qubit. To get the results from our circuit, we use run to execute our circuit, giving the circuit and the backend as arguments. We then use .result() to get the result of this: from result, we can then get the final statevector using .get_statevector(): Note: Python uses j to represent i in complex numbers. We see a vector with two complex elements: 0.+0.j = 0, and 1.+0.j = 1. Let\u2019s now measure our qubit as we would in a real quantum computer and see the result: This time, instead of the statevector we will get the counts for the 0 and 1 results using .get_counts(): We can see that we (unsurprisingly) have a % chance of measuring |1\\rangle.  This time, let\u2019s instead put our qubit into a superposition and see what happens. We will use the state |q_0\\rangle from earlier in this section: \\begin{align*} |q_0\\rangle = \\tfrac{1}{\\sqrt{2}}|0\\rangle + \\tfrac{\\cssId{i}{i}}{\\sqrt{2}}|1\\rangle \\end{align*} We need to add these amplitudes to a python list. To add a complex amplitude, Python uses j for the imaginary unit (we normally call it \"i\" mathematically): And we then repeat the steps for initialising the qubit as before: We can see we have equallessgreater probability of measuring |0\\rangle compared to |1\\rangle. To explain this, we need to talk about measurement.       There is a simple rule for measurement. To find the probability of measuring a state |\\psi \\rangle in the state |x\\rangle we do: \\begin{align*}p(|x\\rangle) = | \\langle x| \\psi \\rangle|^2\\end{align*} The symbols \\langle and | tell us \\langle x | is a row vector. In quantum mechanics we call the column vectors kets and the row vectors bras. Together they make up bra-ket notation. Any ket |a\\rangle has a corresponding bra \\langle a|, and we convert between them using the conjugate transpose.   \\begin{align*} \\quad|a\\rangle = \\begin{bmatrix}a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{bmatrix} \\end{align*} To get the conjugate transpose, the matrix is transposed and the elements are complex conjugated (represented by the \"\u2217\" operation) where complex conjugate of a complex number is a number with an equal real part and an imaginary part equal in magnitude but opposite in sign. This gives the corresponding bra (row vector) as follows: \\begin{align*} \\langle a| = \\begin{bmatrix}a_0^*, & a_1^*, & \\dots & a_n^* \\end{bmatrix} \\end{align*}   \\begin{align*}\\langle a| = \\begin{bmatrix}a_0^*, & a_1^*, & \\dots & a_n^* \\end{bmatrix} \\end{align*} \\begin{align*}|b\\rangle = \\begin{bmatrix}b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_n \\end{bmatrix} \\end{align*} \\begin{align*}\\langle a|b\\rangle = a_0^* b_0 + a_1^* b_1 \\dots a_n^* b_n \\end{align*} We can see that the inner product of two vectors always gives us a scalar. A useful thing to remember is that the inner product of two orthogonal vectors is 0, for example if we have the orthogonal vectors |0\\rangle and |1\\rangle: \\begin{align*}\\langle1|0\\rangle = \\begin{bmatrix} 0 , & 1\\end{bmatrix}\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} = 0\\end{align*} Additionally, remember that the vectors |0\\rangle and |1\\rangle are also normalised (magnitudes are equal to 1): \\begin{align*}\\begin{aligned} \\langle0|0\\rangle &= \\begin{bmatrix} 1 , & 0\\end{bmatrix}\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} = 1 \\\\ \\langle1|1\\rangle &= \\begin{bmatrix} 0 , & 1\\end{bmatrix}\\begin{bmatrix}0 \\\\ 1\\end{bmatrix} = 1 \\end{aligned}\\end{align*} In the equation above, |x\\rangle can be any qubit state. To find the probability of measuring |x\\rangle, we take the inner product of |x\\rangle and the state we are measuring (in this case |\\psi\\rangle), then square the magnitude. This may seem a little convoluted, but it will soon become second nature. If we look at the state |q_0\\rangle from before, we can see the probability of measuring |0\\rangle is indeed 0.5: \\begin{align*}\\begin{aligned} |q_0\\rangle & = \\tfrac{1}{\\sqrt{2}}|0\\rangle + \\tfrac{i}{\\sqrt{2}}|1\\rangle \\\\ \\langle 0| q_0 \\rangle & = \\tfrac{1}{\\sqrt{2}}\\langle 0|0\\rangle + \\tfrac{i}{\\sqrt{2}}\\langle 0|1\\rangle \\\\ & = \\tfrac{1}{\\sqrt{2}}\\cdot 1 + \\tfrac{i}{\\sqrt{2}} \\cdot 0\\\\ & = \\tfrac{1}{\\sqrt{2}}\\\\ |\\langle 0| q_0 \\rangle|^2 & = \\tfrac{1}{2} \\end{aligned}\\end{align*} You should verify the probability of measuring |1\\rangle as an exercise. This rule governs how we get information out of quantum states. It is therefore very important for everything we do in quantum computation. It also immediately implies several important facts.       The rule shows us that amplitudes are related to probabilities. If we want the probabilities to add up to 1 (which they should!), we need to ensure that the statevector is properly normalized. Specifically, we need the magnitude of the state vector to be 1. \\begin{align*} \\langle\\psi|\\psi\\rangle = 1 \\end{align*} Thus if: \\begin{align*} |\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle \\end{align*} Then: \\begin{align*} |\\alpha|^2 + |\\beta|^2 = 1 \\end{align*} This explains the factors of \\sqrt{2} you have seen throughout this chapter. In fact, if we try to give initialize() a vector that isn\u2019t normalised, it will give us an error: You can check your answer in the widget below (accepts answers \u00b11% accuracy, you can use numpy terms such as 'pi' and 'sqrt()' in the vector):   The measurement rule gives us the probability p(|x\\rangle) that a state |\\psi\\rangle is measured as |x\\rangle. Nowhere does it tell us that |x\\rangle can only be either |0\\rangle or |1\\rangle. The measurements we have considered so far are in fact only one of an infinite number of possible ways to measure a qubit. For any orthogonal pair of states, we can define a measurement that would cause a qubit to choose between the two. This possibility will be explored more in the next section. For now, just bear in mind that |x\\rangle is not limited to being simply |0\\rangle or |1\\rangle.   We know that measuring the state |1\\rangle will give us the output 1 with certainty. But we are also able to write down states such as  \\begin{align*}\\begin{bmatrix}0 \\\\ i\\end{bmatrix} = i|1\\rangle.\\end{align*} To see how this behaves, we apply the measurement rule. \\begin{align*} |\\langle x| (i|1\\rangle) |^2 = | i \\langle x|1\\rangle|^2 = |\\langle x|1\\rangle|^2 \\end{align*} Here we find that the factor of i disappears once we take the magnitude of the complex number. This effect is completely independent of the measured state |x\\rangle. It does not matter what measurement we are considering, the probabilities for the state i|1\\rangle are identical to those for |1\\rangle. Since measurements are the only way we can extract any information from a qubit, this implies that these two states are equivalent in all ways that are physically relevant. More generally, we refer to any overall factor \\gamma on a state for which |\\gamma|=1 as a 'global phase'. States that differ only by a global phase are physically indistinguishable. \\begin{align*} |\\langle x| ( \\gamma |a\\rangle) |^2 = | \\gamma \\langle x|a\\rangle|^2 = |\\langle x|a\\rangle|^2 \\end{align*} Note that this is distinct from the phase difference between terms in a superposition, which is known as the 'relative phase'. This becomes relevant once we consider different types of measurement and multiple qubits.   We know that the amplitudes contain information about the probability of us finding the qubit in a specific state, but once we have measured the qubit, we know with certainty what the state of the qubit is. For example, if we measure a qubit in the state: \\begin{align*} |q\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\end{align*} And find it in the state |0\\rangle, if we measure again, there is a 100% chance of finding the qubit in the state |0\\rangle. This means the act of measuring changes the state of our qubits. \\begin{align*} |q\\rangle = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix} \\xrightarrow{\\text{Measure }|0\\rangle} |q\\rangle = |0\\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\end{align*} We sometimes refer to this as collapsing the state of the qubit. It is a potent effect, and so one that must be used wisely. For example, were we to constantly measure each of our qubits to keep track of their value at each point in a computation, they would always simply be in a well-defined state of either |0\\rangle or |1\\rangle. As such, they would be no different from classical bits and our computation could be easily replaced by a classical computation. To achieve truly quantum computation we must allow the qubits to explore more complex states. Measurements are therefore only used when we need to extract an output. This means that we often place all the measurements at the end of our quantum circuit.  We can demonstrate this using Qiskit\u2019s statevector simulator. Let's initialize a qubit in superposition: This should initialize our qubit in the state: \\begin{align*} |q\\rangle = \\tfrac{i}{\\sqrt{2}}|0\\rangle + \\tfrac{1}{\\sqrt{2}}|1\\rangle \\end{align*} We can verify this using the simulator: We can see here the qubit is initialized in the state [0.+0.70710678j 0.70710678+0.j], which is the state we expected. Let\u2019s now create a circuit where we measure this qubit: When we simulate this entire circuit, we can see that one of the amplitudes is always 0: You can re-run this cell a few times to reinitialize the qubit and measure it again. You will notice that either outcome is equally probable, but that the state of the qubit is never a superposition of |0\\rangle and |1\\rangle. Somewhat interestingly, the global phase on the state |0\\rangle survives, but since this is global phase, we can never measure it on a real quantum computer.   We can see that writing down a qubit\u2019s state requires keeping track of two complex numbers, but when using a real quantum computer we will only ever receive a yes-or-no (0 or 1) answer for each qubit. The output of a 10-qubit quantum computer will look like this: 0110111110 Just 10 bits, no superposition or complex amplitudes. When using a real quantum computer, we cannot see the states of our qubits mid-computation, as this would destroy them! This behaviour is not ideal for learning, so Qiskit provides different quantum simulators: By default, the aer_simulator mimics the execution of a real quantum computer, but will also allow you to peek at quantum states before measurement if we include certain instructions in our circuit. For example, here we have included the instruction .save_statevector(), which means we can use .get_statevector() on the result of the simulation.        We saw earlier in this chapter that the general state of a qubit (|q\\rangle) is: \\begin{align*}|q\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\end{align*} \\begin{align*}\\alpha, \\beta \\in \\mathbb{C}\\end{align*} (The second line tells us \\alpha and \\beta are complex numbers). The first two implications in section 2 tell us that we cannot differentiate between some of these states. This means we can be more specific in our description of the qubit.  Firstly, since we cannot measure global phase, we can only measure the difference in phase between the states |0\\rangle and |1\\rangle. Instead of having \\alpha and \\beta be complex, we can confine them to the real numbers and add a term to tell us the relative phase between them: \\begin{align*}|q\\rangle = \\alpha|0\\rangle + e^{i\\phi}\\beta|1\\rangle\\end{align*} \\begin{align*}\\alpha, \\beta, \\phi \\in \\mathbb{R}\\end{align*} Finally, since the qubit state must be normalised, i.e. \\begin{align*}\\sqrt{\\alpha^2 + \\beta^2} = 1\\end{align*} we can use the trigonometric identity: \\begin{align*}\\sqrt{\\sin^2{x} + \\cos^2{x}} = 1\\end{align*} to describe the real \\alpha and \\beta in terms of one variable, \\theta: \\begin{align*}\\alpha = \\cos{\\tfrac{\\theta}{2}}, \\quad \\beta=\\sin{\\tfrac{\\theta}{2}}\\end{align*} From this we can describe the state of any qubit using the two variables \\phi and \\theta: \\begin{align*}|q\\rangle = \\cos{\\tfrac{\\theta}{2}}|0\\rangle + e^{i\\phi}\\sin{\\tfrac{\\theta}{2}}|1\\rangle\\end{align*} \\begin{align*}\\theta, \\phi \\in \\mathbb{R}\\end{align*}   We want to plot our general qubit state: \\begin{align*}|q\\rangle = \\cos{\\tfrac{\\theta}{2}}|0\\rangle + e^{i\\phi}\\sin{\\tfrac{\\theta}{2}}|1\\rangle\\end{align*} If we interpret \\theta and \\phi as spherical co-ordinates (r = 1, since the magnitude of the qubit state is 1), we can plot any single qubit state on the surface of a sphere, known as the Bloch sphere. Below we have plotted a qubit in the state |{+}\\rangle. In this case, \\theta = \\pi/2 and \\phi = 0. (Qiskit has a function to plot a bloch sphere, plot_bloch_vector(), but at the time of writing it only takes cartesian coordinates. We have included a function that does the conversion automatically). You can also try this interactive Bloch sphere demo.     Use plot_bloch_vector() or plot_bloch_sphere_spherical() to plot a qubit in the states: We have also included below a widget that converts from spherical co-ordinates to cartesian, for use with plot_bloch_vector():", "url": "https://learn.qiskit.org/course/ch-states/representing-qubit-states"}